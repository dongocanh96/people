Title: Cứ đi là đến (Go)
Date: 2021-03-11
Category: draft
Tags: golang, go
Slug: gop2
Authors: hvnsweeting
Summary: Học vừa đủ Golang để nguy hiểm - phần 2 - hết

Phần tiếp theo của loạt bài viết **Học vừa đủ Golang để nguy hiểm**
Chi tiết về các khái niệm chỉ có trong Go mà không có trong Python như Pointer,
sự khác biệt về cách tổ chức package trong Go, declaration & initialization
(khai báo và khởi tạo variable), cùng các standard library quan trọng nhất
cho một SysAdmin/DevOps.

Code trong loạt bài này lược bỏ phần package/import/declare function main, người đọc tự thêm vào để chạy.
```go
package main

import "fmt"

func main() {
	fmt.Println("pp.pymi.vn")
    // WRITE CODE HERE
}
```

## Extended Backus-Naur Form (EBNF)
Cú pháp dùng để mô tả Go syntax có tên EBNF.

Có vẻ không dễ đọc, nhưng không phải là không thể đọc nổi, bỏ qua nếu
bạn không quan tâm. Một ví dụ:

```go
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
```

https://golang.org/ref/spec#Notation

[Python 3.9 dùng EBNF kết hợp với PEG](https://docs.python.org/3.9/reference/grammar.html)

## Declaration & initialization

```go
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
```
Để sử dụng 1 biến trong Go, cần làm 2 bước declaration (khai báo) và
initialization (khởi tạo giá trị).
Hai bước này giống như 1. lên phường đăng ký 2. về nhà tổ chức đám cưới vậy.

```go
var x int
var (
    y bool
    z float64
)
println(x, y, z)

// Output
// 0 false +0.000000e+000
```
Khai báo biến sử dụng từ khóa `var`, nếu không gán giá trị khởi tạo
(initialization), các biến sẽ có [zero
value](https://golang.org/ref/spec#The_zero_value) tương ứng với kiểu
của nó. Tức int sẽ = 0, bool = false, string = "". Nếu có, biểu thức theo sau sẽ được tính toán và biến sẽ chứa giá trị này.


```go
var y int = 1
var x int = y + 1
print(x)
// Output
// 2
```

*Short variable declarations*, không cần ghi type, và dùng dấu `:`

```bnf
ShortVarDecl = IdentifierList ":=" ExpressionList .
```

```go
s := "Pymier"
x, y := 5, 7
x, z := 6, 9
print(s, x, y, z)

// Pymier679
```

https://golang.org/ref/spec#Variable_declarations

## Scope
Mỗi block (đánh dấu bởi `{}`) như trong if/for/switch hay function
sẽ tạo 1 không gian tên

```go
	var x int = 3
	{
		var x string = "Python"
		println(x)
	}
	println(x)
	//Python
	//3
```

điều này nghĩa là nếu khai báo 1 variable trong vòng `for` hay trong
điều kiện `if`, thì chúng không thoát ra ngoài khỏi các khối ấy, sẽ
không có hiện lượng **leak** variable như trong Python for:

```python
p = "Mi"
s = 0
for p in range(3):
    s = s + p
print(p)
# Kết quả hiện ra 2, không hiện ra Mi
print("{} is hoc sinh gioi".format(p))
```

*Tính năng* này dễ dẫn đến bug nếu ta chuyển code đi xung quanh, hay vô tình đặt tên giống nhau tại các nơi khác, trong cùng 1 function.

Trong Go:

```go
var p string = "Mi"
s := 0
for p := 0; p < 3; p++ {
    s = s + p
}
println(s, p)
// Output
// 3 Mi
```

https://golang.org/ref/spec#Declarations_and_scope

## Struct
struct là khác biệt lớn đầu tiên với người code Python không dùng class (mà dùng dict).
Do trong Go không thể tạo 1 map chứa các value khác kiểu, không
có đoạn code tương tự với code Python sau đây nếu dùng map:

```python
boy = {"name": "Pika", "age": 18}
students = {
    20088888: boy,
    20089999: {"name": "Doraemon", "age": 20},
}
print(students[20088888]["name"])
# Pika
```
Vậy nên khi cần biểu diễn 1 object trong Go, cần tạo struct:

```go
type Student struct {
    name string
    age  int
}
boy := Student{name: "Pika", age: 18}
fmt.Printf("%v\n", boy)
// {Pika 18}
students := map[int]Student{
    20088888: boy,
    20089999: Student{name: "Doraemon", age: 20},
}
fmt.Println(students[20088888].name)
// Pika
```
Và vì thế, map trong Go sẽ chỉ còn được dùng khi cần "ghép cặp" key-value, tối ưu cho việc tìm kiếm theo key. BIG NOTE: Go không có kiểu set built-in.

Để viết code Python "đúng" nhất theo Go, hãy tạo class mỗi khi cần 1 object, việc này hợp lý trên lý thuyết, nhưng trong thực hành, khi nhận được 1 JSON string rồi `json.loads` lên, không mấy ai ngồi viết class cả
(PS: việc này ngày càng phổ biến trong Python với sự hỗ trợ của [`dataclasses`](https://docs.python.org/3.9/library/dataclasses.html) hay thư viện [marshmallow](https://marshmallow.readthedocs.io/en/stable/quickstart.html#deserializing-objects-loading)). Trong Go thì bắt  buộc phải ngồi viết struct cho JSON đó, hoặc dùng thư viện cung cấp sẵn struct tương ứng giá trị JSON nói trên nếu dịch vụ đó có Go client SDK.

## Pointer
- is memory address
- using for : receiving result
- using for: sharing
- heap
- link to dave chenny blog explain pointer

## Method
- Just syntactic sugar
- Almost use pointer receiver

## Interface
- for methods, not type

## Packages
- init
- internal package

## Concurrency
- is hard
- go routing leak
- mem leak

## Stdlib for DevOps

## Popular lib

## Show the cost
x in list

## Go đơn giản, nhưng không dễ


## Like & Dislike
## Kết luận


## References

HVN at [http://pymi.vn](http://pymi.vn) and [https://www.familug.org](https://www.familug.org).
